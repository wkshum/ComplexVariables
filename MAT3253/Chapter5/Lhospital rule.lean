/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).
-/


/-
(1) The basic version of L'Hospital rule
Assumptions: f(z‚ÇÄ)=g(z‚ÇÄ)=0, and g'(z‚ÇÄ) ‚â† 0
Then, lim (f(z)/g(z)) = f'(z‚ÇÄ)/g'(z‚ÇÄ)

(2) Alternate form of L'Hospital rule 
Assumptions: f(z‚ÇÄ)=0, and g(z) has a simple zero at z‚ÇÄ
Then, lim (f(z)/g(z)) = f'(z‚ÇÄ)/g'(z‚ÇÄ)

(3) L'Hospital rule at the point at infinity
Assumptions: f(‚àû)=g(‚àû)=0, and g'(‚àû) ‚â† 0
Then, lim (f(z)/g(z)) = f'(‚àû)/g'(‚àû)

-/



import Mathlib.Tactic
import Mathlib.Analysis.Complex.Conformal

noncomputable section

open Complex Filter Topology


/-- 
L'H√¥pital's Rule for complex differentiable functions at a point where both vanish.
If f(z‚ÇÄ) = 0, g(z‚ÇÄ) = 0, and g'(z‚ÇÄ) ‚â† 0, then lim (f(z)/g(z)) = f'(z‚ÇÄ)/g'(z‚ÇÄ).

We can comment out the line `{f g : ‚ÑÇ ‚Üí ‚ÑÇ} {z‚ÇÄ f' g' : ‚ÑÇ}` and replace it with `{f g : ‚Ñù ‚Üí ‚Ñù} {z‚ÇÄ f' g' : ‚Ñù}`, and
 the same proof will work.
-/

theorem complex_lhopital_zero_zero
--    {f g : ‚Ñù ‚Üí ‚Ñù} {z‚ÇÄ f' g' : ‚Ñù}
    {f g : ‚ÑÇ ‚Üí ‚ÑÇ} {z‚ÇÄ f' g' : ‚ÑÇ}
    (hf : HasDerivAt f f' z‚ÇÄ)
    (hg : HasDerivAt g g' z‚ÇÄ)
    (hf0 : f z‚ÇÄ = 0)
    (hg0 : g z‚ÇÄ = 0)
    (hg_ne : g' ‚â† 0) :
    Tendsto (fun z ‚Ü¶ f z / g z) (ùìù[‚â†] z‚ÇÄ) (ùìù (f' / g')) := by

  -- By definition of the derivative, we know that 
  -- $\lim_{z \to z_0} \frac{f(z) - f(z_0)}{z - z_0} = f'(z_0)$ 
  -- and $\lim_{z \to z_0} \frac{g(z) - g(z_0)}{z - z_0} = g'(z_0)$.
  have h_deriv : Filter.Tendsto (fun z => (f z - f z‚ÇÄ) / (z - z‚ÇÄ)) (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds f') 
    ‚àß Filter.Tendsto (fun z => (g z - g z‚ÇÄ) / (z - z‚ÇÄ)) (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds g') := by
    -- By definition of HasDerivAt, we know that the limit of (f(z) - f(z‚ÇÄ)) / (z - z‚ÇÄ) as z approaches z‚ÇÄ is f', and similarly for g.
    have h_deriv_f : Filter.Tendsto (fun z => (f z - f z‚ÇÄ) / (z - z‚ÇÄ)) 
      (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds f') := by
      rw [ hasDerivAt_iff_tendsto_slope ] at hf
      simpa [ div_eq_inv_mul ] using hf
    have h_deriv_g : Filter.Tendsto (fun z => (g z - g z‚ÇÄ) / (z - z‚ÇÄ))
      (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds g') := by
      rw [ hasDerivAt_iff_tendsto_slope ] at hg
      simpa [ div_eq_inv_mul ] using hg
    exact ‚ü®h_deriv_f, h_deriv_g‚ü©
  -- Since the denominator is non-zero, we can apply the fact that 
  -- the limit of a quotient is the quotient of the limits.
  have h_quot : Filter.Tendsto (fun z => ((f z - f z‚ÇÄ) / (z - z‚ÇÄ)) / ((g z - g z‚ÇÄ) / (z - z‚ÇÄ))) 
    (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds (f' / g')) := by
    exact h_deriv.1.div h_deriv.2 hg_ne

  -- Apply the congruence rule. 
  -- This allows us to prove the limits are the same if the functions are equal near z‚ÇÄ.
  apply h_quot.congr'

  -- Filter to the set of points where z ‚â† z‚ÇÄ.
  -- The filter ùìù[‚â†] z‚ÇÄ guarantees we only care about z where z ‚â† z‚ÇÄ.
  filter_upwards [self_mem_nhdsWithin] with z hz

  -- Substitute f(z‚ÇÄ) = 0 and g(z‚ÇÄ) = 0 and simplify "something - 0"
  simp only [hf0, hg0, sub_zero]

  -- Perform the algebraic cancellation of (z - z‚ÇÄ).
  -- We need to establish that the denominator (z - z‚ÇÄ) is not zero.
  have h_ne : z - z‚ÇÄ ‚â† 0 := sub_ne_zero.mpr hz
  
  -- Use field_simp to cancel the common factor.
  -- Alternatively, you could use: rw [div_div_div_cancel_right _ _ h_ne]
  field_simp [h_ne]




/-
Checking definitions of iteratedDeriv, HasDerivAt, and deriv.
-/
#check iteratedDeriv
#check HasDerivAt
#check deriv

/-- 
Definition: A function g has a zero of order m at z‚ÇÄ if 
its first m-1 derivatives vanish, and the m-th derivative is non-zero.
-/
def HasZeroOrder (g : ‚ÑÇ ‚Üí ‚ÑÇ) (z‚ÇÄ : ‚ÑÇ) (m : ‚Ñï) : Prop :=
  (‚àÄ k < m, iteratedDeriv k g z‚ÇÄ = 0) ‚àß (iteratedDeriv m g z‚ÇÄ ‚â† 0)



/-
L'Hopital's rule for complex functions at a point where 
the denominator has a simple zero (order 1). The formula f'/g' 
is valid only for m=1.
-/
open Filter Topology

theorem complex_lhopital_zero_zero'
    {f g : ‚ÑÇ ‚Üí ‚ÑÇ} {z‚ÇÄ f' g' : ‚ÑÇ}
    (hf : HasDerivAt f f' z‚ÇÄ)
    (hg : HasDerivAt g g' z‚ÇÄ)
    (hf0 : f z‚ÇÄ = 0)
    (hg0 : g z‚ÇÄ = 0)
    (m : ‚Ñï) (hm : m = 1)
    (hg_zero_order : HasZeroOrder g z‚ÇÄ m) :
    Tendsto (fun z ‚Ü¶ f z / g z) (ùìù[‚â†] z‚ÇÄ) (ùìù (f' / g')) := by
      rw [ hasDerivAt_iff_tendsto_slope_zero ] at hf hg;
      -- We'll use the fact that if the denominator is non-zero and the numerator tends to a limit, then the quotient tends to the quotient of the limits.
      have h_div : Filter.Tendsto (fun t => (f (z‚ÇÄ + t) - f z‚ÇÄ) / (g (z‚ÇÄ + t) - g z‚ÇÄ)) (nhdsWithin 0 {0}·∂ú) (nhds (f' / g')) := by
        have h_div : Filter.Tendsto (fun t => (f (z‚ÇÄ + t) - f z‚ÇÄ) / t / ((g (z‚ÇÄ + t) - g z‚ÇÄ) / t)) (nhdsWithin 0 {0}·∂ú) (nhds (f' / g')) := by
          convert hf.div hg _ using 1;
          ¬∑ ext; simp +decide [ div_eq_inv_mul ] ;
          ¬∑ simp_all +decide [ HasZeroOrder ];
            contrapose! hg_zero_order; rw [ show deriv g z‚ÇÄ = g' by exact ( HasDerivAt.deriv <| by rw [ hasDerivAt_iff_tendsto_slope_zero ] ; simpa [ div_eq_inv_mul, hg0 ] using hg ) ] ; aesop;
        refine' h_div.congr' ( by filter_upwards [ self_mem_nhdsWithin ] with t ht using by rw [ div_div_div_cancel_right‚ÇÄ ht ] );
      rw [ Metric.tendsto_nhdsWithin_nhds ] at *;
      intro Œµ hŒµ; rcases h_div Œµ hŒµ with ‚ü® Œ¥, hŒ¥, H ‚ü© ; exact ‚ü® Œ¥, hŒ¥, fun { x } hx‚ÇÅ hx‚ÇÇ => by simpa [ * ] using H ( sub_ne_zero_of_ne hx‚ÇÅ ) <| by simpa [ dist_eq_norm ] using hx‚ÇÇ ‚ü© ;

/-
For the point at infinity, we define `HasDerivAtInfinity f f'` 
as $\lim_{z \to \infty} z f(z) = f'$. This corresponds to the 
derivative of $f(1/w)$ at $w=0$ assuming $f(\infty)=0$.
We show that if `HasDerivAtInfinity f f'` and `HasDerivAtInfinity g g'` 
with $g' \neq 0$, then $\lim_{z \to \infty} f(z)/g(z) = f'/g'$.
-/


/-
L'Hopital's rule for the form 0/0 at infinity.
    If f and g behave like f'/z and g'/z at infinity, then f/g tends to f'/g'.
-/
def HasDerivAtInfinity (f : ‚ÑÇ ‚Üí ‚ÑÇ) (f' : ‚ÑÇ) :=
  Filter.Tendsto (fun z ‚Ü¶ z * f z) (Filter.cocompact ‚ÑÇ) (nhds f')

theorem complex_lhopital_infinity_infinity
    {f g : ‚ÑÇ ‚Üí ‚ÑÇ} {f' g' : ‚ÑÇ}
    (hf : HasDerivAtInfinity f f')
    (hg : HasDerivAtInfinity g g')
    (hg_ne : g' ‚â† 0) :
    Filter.Tendsto (fun z ‚Ü¶ f z / g z) (Filter.cocompact ‚ÑÇ) 
       (nhds (f' / g')) := by
      -- We have f(z)/g(z) = (z*f(z)) / (z*g(z)) for z ‚â† 0.
      suffices h_eq : Filter.Tendsto (fun z => (z * f z) / (z * g z)) 
        (Filter.cocompact ‚ÑÇ) (nhds (f' / g')) by
        refine' h_eq.congr' _ ; filter_upwards [ ( Filter.mem_cocompact.mpr ‚ü® Metric.closedBall 0 1, ProperSpace.isCompact_closedBall _ _, by aesop_cat ‚ü© ) ] with x hx ; 
          by_cases h : x = 0 <;> simp_all +decide [ mul_div_mul_left ] ;
      -- Since $z * f(z) \to f'$ and $z * g(z) \to g'$ as $z \to \infty$, we can use the fact that the ratio of two functions that tend to their respective limits also tends to the ratio of the limits.
      have h_tendsto : Filter.Tendsto (fun z => z * f z) (Filter.cocompact ‚ÑÇ) (nhds f') ‚àß Filter.Tendsto 
          (fun z => z * g z) (Filter.cocompact ‚ÑÇ) (nhds g') := by
        unfold HasDerivAtInfinity at hf hg; 
        aesop;
      exact h_tendsto.1.div h_tendsto.2 hg_ne

