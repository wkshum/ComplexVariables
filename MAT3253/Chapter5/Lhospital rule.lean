/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).
-/


/-
 L'hospital rule for 0/0 
 The proof works for complex variable and for real variable. 
 We can comment out the line `{f g : ‚ÑÇ ‚Üí ‚ÑÇ} {z‚ÇÄ f' g' : ‚ÑÇ}` and replace it with `{f g : ‚Ñù ‚Üí ‚Ñù} {z‚ÇÄ f' g' : ‚Ñù}`, and
 the same proof will work.
-/

import Mathlib.Tactic
import Mathlib.Analysis.Complex.Conformal

noncomputable section

open Complex Filter Topology

/-- 
L'H√¥pital's Rule for complex differentiable functions at a point where both vanish.
If f(z‚ÇÄ) = 0, g(z‚ÇÄ) = 0, and g'(z‚ÇÄ) ‚â† 0, then lim (f(z)/g(z)) = f'(z‚ÇÄ)/g'(z‚ÇÄ).
-/
theorem complex_lhopital_zero_zero
--    {f g : ‚Ñù ‚Üí ‚Ñù} {z‚ÇÄ f' g' : ‚Ñù}
    {f g : ‚ÑÇ ‚Üí ‚ÑÇ} {z‚ÇÄ f' g' : ‚ÑÇ}
    (hf : HasDerivAt f f' z‚ÇÄ)
    (hg : HasDerivAt g g' z‚ÇÄ)
    (hf0 : f z‚ÇÄ = 0)
    (hg0 : g z‚ÇÄ = 0)
    (hg_ne : g' ‚â† 0) :
    Tendsto (fun z ‚Ü¶ f z / g z) (ùìù[‚â†] z‚ÇÄ) (ùìù (f' / g')) := by

  -- By definition of the derivative, we know that 
  -- $\lim_{z \to z_0} \frac{f(z) - f(z_0)}{z - z_0} = f'(z_0)$ 
  -- and $\lim_{z \to z_0} \frac{g(z) - g(z_0)}{z - z_0} = g'(z_0)$.
  have h_deriv : Filter.Tendsto (fun z => (f z - f z‚ÇÄ) / (z - z‚ÇÄ)) (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds f') 
    ‚àß Filter.Tendsto (fun z => (g z - g z‚ÇÄ) / (z - z‚ÇÄ)) (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds g') := by
    -- By definition of HasDerivAt, we know that the limit of (f(z) - f(z‚ÇÄ)) / (z - z‚ÇÄ) as z approaches z‚ÇÄ is f', and similarly for g.
    have h_deriv_f : Filter.Tendsto (fun z => (f z - f z‚ÇÄ) / (z - z‚ÇÄ)) 
      (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds f') := by
      rw [ hasDerivAt_iff_tendsto_slope ] at hf
      simpa [ div_eq_inv_mul ] using hf
    have h_deriv_g : Filter.Tendsto (fun z => (g z - g z‚ÇÄ) / (z - z‚ÇÄ))
      (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds g') := by
      rw [ hasDerivAt_iff_tendsto_slope ] at hg
      simpa [ div_eq_inv_mul ] using hg
    exact ‚ü®h_deriv_f, h_deriv_g‚ü©
  -- Since the denominator is non-zero, we can apply the fact that 
  -- the limit of a quotient is the quotient of the limits.
  have h_quot : Filter.Tendsto (fun z => ((f z - f z‚ÇÄ) / (z - z‚ÇÄ)) / ((g z - g z‚ÇÄ) / (z - z‚ÇÄ))) 
    (nhdsWithin z‚ÇÄ {z‚ÇÄ}·∂ú) (nhds (f' / g')) := by
    exact h_deriv.1.div h_deriv.2 hg_ne

  -- Apply the congruence rule. 
  -- This allows us to prove the limits are the same if the functions are equal near z‚ÇÄ.
  apply h_quot.congr'

  -- Filter to the set of points where z ‚â† z‚ÇÄ.
  -- The filter ùìù[‚â†] z‚ÇÄ guarantees we only care about z where z ‚â† z‚ÇÄ.
  filter_upwards [self_mem_nhdsWithin] with z hz

  -- Substitute f(z‚ÇÄ) = 0 and g(z‚ÇÄ) = 0 and simplify "something - 0"
  simp only [hf0, hg0, sub_zero]

  -- Perform the algebraic cancellation of (z - z‚ÇÄ).
  -- We need to establish that the denominator (z - z‚ÇÄ) is not zero.
  have h_ne : z - z‚ÇÄ ‚â† 0 := sub_ne_zero.mpr hz
  
  -- Use field_simp to cancel the common factor.
  -- Alternatively, you could use: rw [div_div_div_cancel_right _ _ h_ne]
  field_simp [h_ne]



/-- 
Definition: A function g has a zero of order m at z‚ÇÄ if 
its first m-1 derivatives vanish, and the m-th derivative is non-zero.
-/
def HasZeroOrder (g : ‚ÑÇ ‚Üí ‚ÑÇ) (z‚ÇÄ : ‚ÑÇ) (m : ‚Ñï) : Prop :=
  (‚àÄ k < m, iteratedDeriv k g z‚ÇÄ = 0) ‚àß (iteratedDeriv m g z‚ÇÄ ‚â† 0)

/-
Checking definitions of iteratedDeriv, HasDerivAt, and deriv.
-/
#check iteratedDeriv
#check HasDerivAt
#check deriv

/-
L'Hopital's rule for complex functions at a point where 
the denominator has a simple zero (order 1). The formula f'/g' 
is valid only for m=1.
-/
open Filter Topology

theorem complex_lhopital_zero_zero'
    {f g : ‚ÑÇ ‚Üí ‚ÑÇ} {z‚ÇÄ f' g' : ‚ÑÇ}
    (hf : HasDerivAt f f' z‚ÇÄ)
    (hg : HasDerivAt g g' z‚ÇÄ)
    (hf0 : f z‚ÇÄ = 0)
    (hg0 : g z‚ÇÄ = 0)
    (m : ‚Ñï) (hm : m = 1)
    (hg_zero_order : HasZeroOrder g z‚ÇÄ m) :
    Tendsto (fun z ‚Ü¶ f z / g z) (ùìù[‚â†] z‚ÇÄ) (ùìù (f' / g')) := by
      rw [ hasDerivAt_iff_tendsto_slope_zero ] at hf hg;
      -- We'll use the fact that if the denominator is non-zero and the numerator tends to a limit, then the quotient tends to the quotient of the limits.
      have h_div : Filter.Tendsto (fun t => (f (z‚ÇÄ + t) - f z‚ÇÄ) / (g (z‚ÇÄ + t) - g z‚ÇÄ)) (nhdsWithin 0 {0}·∂ú) (nhds (f' / g')) := by
        have h_div : Filter.Tendsto (fun t => (f (z‚ÇÄ + t) - f z‚ÇÄ) / t / ((g (z‚ÇÄ + t) - g z‚ÇÄ) / t)) (nhdsWithin 0 {0}·∂ú) (nhds (f' / g')) := by
          convert hf.div hg _ using 1;
          ¬∑ ext; simp +decide [ div_eq_inv_mul ] ;
          ¬∑ simp_all +decide [ HasZeroOrder ];
            contrapose! hg_zero_order; rw [ show deriv g z‚ÇÄ = g' by exact ( HasDerivAt.deriv <| by rw [ hasDerivAt_iff_tendsto_slope_zero ] ; simpa [ div_eq_inv_mul, hg0 ] using hg ) ] ; aesop;
        refine' h_div.congr' ( by filter_upwards [ self_mem_nhdsWithin ] with t ht using by rw [ div_div_div_cancel_right‚ÇÄ ht ] );
      rw [ Metric.tendsto_nhdsWithin_nhds ] at *;
      intro Œµ hŒµ; rcases h_div Œµ hŒµ with ‚ü® Œ¥, hŒ¥, H ‚ü© ; exact ‚ü® Œ¥, hŒ¥, fun { x } hx‚ÇÅ hx‚ÇÇ => by simpa [ * ] using H ( sub_ne_zero_of_ne hx‚ÇÅ ) <| by simpa [ dist_eq_norm ] using hx‚ÇÇ ‚ü© ;

